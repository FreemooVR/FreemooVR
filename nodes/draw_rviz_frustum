#!/usr/bin/env python
import numpy as np
import argparse
import json
import threading

import roslib; roslib.load_manifest('flyvr')
roslib.load_manifest('visualization_msgs')
import rospy

import tf.transformations
from sensor_msgs.msg import CameraInfo
import sensor_msgs.msg
import std_msgs.msg
from geometry_msgs.msg import Point, Pose, Transform
import geometry_msgs.msg
import tf.broadcaster
import tf.msg
from visualization_msgs.msg import Marker, MarkerArray

import simple_geom
import display_client
import camera_model

def v3(arr):
    assert arr.ndim==1
    assert arr.shape[0]==3
    return Point(x=arr[0],y=arr[1],z=arr[2])

class MyApp:
    def __init__(self,name):
        self.name = name
        self.intrinsics = None
        self.translation = None
        self.rotation = None
        self._lock = threading.Lock()
        self.tl = tf.TransformListener()
        self.cam = None

        rospy.Subscriber(self.get_frame_id()+'/camera_info',
                         CameraInfo, self.on_camera_info)
        self.topic_name = '/pinhole_markers'
        self.publisher = rospy.Publisher(self.topic_name, MarkerArray)#, latch=latch)
        rospy.Timer(rospy.Duration(1.0/20.0), self.on_timer) # 20 fps

    def get_frame_id(self):
        return '/'+self.name

    def on_camera_info(self, msg):
        with self._lock:
            self.intrinsics = msg

    def on_timer(self, _):
        now = rospy.Time.now()
        try:
            translation,rotation = self.tl.lookupTransform('/map',
                                                           self.get_frame_id(),
                                                           now)
        except (tf.LookupException, tf.ExtrapolationException) as err:
            return

        with self._lock:
            self.translation = translation
            self.rotation = rotation

        self.new_data()

    def new_data(self):
        with self._lock:
            if (self.translation is None or
                self.rotation is None or
                self.intrinsics is None):
                return
            newcam = camera_model.load_from_ROS_tf( translation=self.translation,
                                                    rotation=self.rotation,
                                                    intrinsics=self.intrinsics)
        self.cam = newcam

        self.draw()

    def draw(self,scale=1.0):
        cam = self.cam
        uv_raw = np.array([[0,0],
                           [0,cam.height],
                           [cam.width, cam.height],
                           [cam.width, 0],
                           [0,0]])
        pts3d_near = cam.project_pixel_to_3d_ray( uv_raw, distorted=True, distance=0.1*scale)
        pts3d_far = cam.project_pixel_to_3d_ray( uv_raw, distorted=True, distance=scale)

        frame_id = '/map'

        markers = []

        # ring at near depth
        NEAR_RING=0
        near_ring = marker = Marker()
        marker.header.frame_id = frame_id
        marker.id = NEAR_RING
        marker.type = Marker.LINE_STRIP
        marker.action = Marker.ADD
        marker.scale.x = 0.01; #line width
        marker.color.a = 1.0;
        marker.color.r = 0.6;
        marker.color.g = 1.0;
        marker.color.b = 0.6;
        marker.points = [v3(pts3d_near[i]) for i in range( pts3d_near.shape[0] ) ]
        markers.append(marker)

        # ring at far depth
        FAR_RING = 1
        far_ring = marker = Marker()
        marker.header.frame_id = frame_id
        marker.id = FAR_RING
        marker.type = Marker.LINE_STRIP
        marker.action = Marker.ADD
        marker.scale.x = 0.01; #line width
        marker.color.a = 1.0;
        marker.color.r = 0.6;
        marker.color.g = 1.0;
        marker.color.b = 0.6;
        marker.points = [v3(pts3d_far[i]) for i in range( pts3d_far.shape[0] ) ]
        markers.append(marker)

        # connectors
        for i in range(len(pts3d_near)-1):
            ID = 2+i
            pts3d = np.vstack((pts3d_near[i,:],pts3d_far[i,:]))

            marker = Marker()
            marker.header.frame_id = frame_id
            marker.id = ID
            marker.type = Marker.LINE_STRIP
            marker.action = Marker.ADD
            marker.scale.x = 0.01; #line width
            marker.color.a = 1.0;
            marker.color.r = 0.6;
            marker.color.g = 1.0;
            marker.color.b = 0.6;
            marker.points = [v3(pts3d[i]) for i in range( pts3d.shape[0] ) ]
            markers.append(marker)

        marray = MarkerArray(markers)
        self.publisher.publish(marray)

    def run(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('draw_camera')

    parser = argparse.ArgumentParser()

    parser.add_argument('--name', type=str, default='pinhole_cal')

    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    app = MyApp(args.name)
    app.run()
