#!/usr/bin/env python
import numpy as np
import argparse
import json
import threading

import roslib; roslib.load_manifest('flyvr')
import rospy

import tf.transformations
from sensor_msgs.msg import CameraInfo
import sensor_msgs.msg
import std_msgs.msg
from geometry_msgs.msg import Pose, Transform
import geometry_msgs.msg
import tf.broadcaster
import tf.msg

import simple_geom
import display_client
import camera_model
from flyvr.coord_system import body_frame_to_camera_frame

def _float_to_uint8_plane( farr ):
    maxval = np.nanmax( farr )
    if np.isnan(maxval):
        # all nans
        return np.zeros( farr.shape, dtype=np.uint8 )
    minval = np.nanmin( farr )
    farr[ np.isnan(farr) ] = minval

    range = maxval-minval
    scale = 255.0/range

    zeroed = farr-minval
    scaled = zeroed*scale
    return scaled.astype( np.uint8 )

def float_to_uint8(farr):
    arr = np.empty( farr.shape, dtype=np.uint8 )
    if farr.ndim==2:
        arr[:,:] = _float_to_uint8_plane( farr )
    elif farr.ndim==3:
        for i in range( farr.shape[2] ):
            arr[:,:,i] = _float_to_uint8_plane( farr[:,:,i] )
    else:
        raise ValueError('cannot convert array')
    return arr

class MyApp:
    def __init__(self, ds, viewport, cam, geometry_filename, mode='StimulusPinholeDisplay'):
        self.mode = mode
        self.dsc = display_client.DisplayServerProxy(ds,wait=True)

        if self.mode not in ['Stimulus2DBlit','StimulusPinholeDisplay']:
            raise ValueError('cannot operate in mode %r'%self.mode)
        self.dsc.set_mode(self.mode)

        self.geom = simple_geom.Geometry(filename=geometry_filename)

        if viewport:
            self.mask = self.dsc.get_virtual_display_mask(viewport)
        else:
            self.mask = None

        self.name = 'pinhole_cal'
        self.cam = cam
        self.intr_pub = rospy.Publisher(self.name+'/camera_info',
                                        CameraInfo, latch=True)
        self.intrinsic_msg = cam.get_intrinsics_as_msg()
        now = rospy.Time.now()
        self.intrinsic_msg.header.stamp = now
        self.intrinsic_msg.header.frame_id = self.get_frame_id()
        self.intr_pub.publish( self.intrinsic_msg )

        self.im_pub = rospy.Publisher(self.name+'/image',
                                      sensor_msgs.msg.Image)


        self.tf_b = tf.broadcaster.TransformBroadcaster()

        self._new_image = False
        self.send_lock = threading.Lock()

        rospy.Subscriber("pose", Pose, self.on_pose)
        rospy.Timer(rospy.Duration(1.0), self.on_timer1) # every second
        rospy.Timer(rospy.Duration(1/20.0), self.send_image) # try for 20 fps

    def get_frame_id(self):
        return '/'+self.name

    def on_timer1(self, _):
        now = rospy.Time.now()
        self.intrinsic_msg.header.stamp = now
        self.intr_pub.publish( self.intrinsic_msg )

    def on_pose(self, pose_msg):
        translation = []
        for attr in 'xyz':
            translation.append(getattr( pose_msg.position, attr))
        rotation = []
        for attr in 'xyzw':
            rotation.append( getattr( pose_msg.orientation, attr ) )

        # convert body pose to camera pose
        rotation_cam = body_frame_to_camera_frame(rotation)

        # now load new camera with this pose
        self.cam = camera_model.load_from_ROS_tf( translation=translation,
                                                  rotation=rotation_cam,
                                                  intrinsics=self.cam.get_intrinsics_as_msg(),
                                                  name=self.cam.name )


        now = rospy.Time.now()
        future = now + rospy.Duration(0.010) # 10 msec in future

        self.tf_b.sendTransform( translation,
                                 rotation_cam,
                                 future,
                                 self.get_frame_id(),
                                 '/map',
                                 )
        if 0:
            self.tf_b.sendTransform( translation,
                                     rotation,
                                     future,
                                     self.get_frame_id()+'_body',
                                     '/map',
                                     )

        if self.mode == 'Stimulus2DBlit':
            self._new_image = True

    def send_image(self,_):
        if not self._new_image:
            return

        with self.send_lock:
            center = np.array([self.geom.model.get_center()])

            farr = self.geom.compute_for_camera_view( self.cam )
            arr = float_to_uint8(farr)

            if 1:
                # send image to RViz
                now = rospy.Time.now()
                msg = sensor_msgs.msg.Image()
                msg.header.frame_id = self.get_frame_id()
                msg.header.stamp = now

                msg.width = self.cam.width
                msg.height = self.cam.height
                if arr.ndim==2:
                    msg.encoding = 'mono8'
                else:
                    msg.encoding = 'rgb8'
                msg.is_bigendian = 0
                msg.step = self.cam.width

                msg.data = arr.ravel().tolist()

                self.im_pub.publish(msg)

            if 1:
                # send image to display server
                if arr.shape!=(self.dsc.height,self.dsc.width):
                    arr = arr[0:min(self.dsc.height,arr.shape[0]),0:min(self.dsc.width,arr.shape[1]),:]
                if self.mask != None:
                    masks = np.dstack([self.mask for i in range(0,arr.shape[-1])])
                    if arr.shape != masks.shape:
                        arr = np.resize(arr, masks.shape)
                    arr *= masks
                self.dsc.show_pixels(arr)

    def run(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('drive_extrinsic_display_calibration')

    parser = argparse.ArgumentParser()

    parser.add_argument('--intrinsic_fname', type=str, required=True,
                        help='filename  (.bag or .yaml) intrinsic parameters')

    parser.add_argument('--geom_fname', type=str, required=True,
                        help='filename  (.json) specifying display geometry')

    parser.add_argument('--display_server', type=str,
                        required=True,
                        help='the path of the display server to configure')

    parser.add_argument('--viewport', type=str,
                        help='only show on this viewport')

    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    cam = camera_model.load_camera_from_file( args.intrinsic_fname,
                                              extrinsics_required=False )
    app = MyApp(args.display_server,
                args.viewport,
                cam, args.geom_fname)
    app.run()
