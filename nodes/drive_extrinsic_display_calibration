#!/usr/bin/env python
import numpy as np
import argparse

import roslib; roslib.load_manifest('flyvr')
import rospy

import tf.transformations
from sensor_msgs.msg import CameraInfo
import std_msgs.msg
from geometry_msgs.msg import Pose, Transform

import display_client
import camera_model

class MyApp:
    def __init__(self, cam, geometry_filename):
        display_client.DisplayServerProxy.set_stimulus_mode(
            'StimulusPinholeDisplay')
        intr_pub = rospy.Publisher('/pinhole_cal/camera_info',
                                   CameraInfo, latch=True)
        intr_pub.publish( cam.get_intrinsics_as_msg() )

        geom_pub = rospy.Publisher('/pinhole_cal/geometry_filename',
                                   std_msgs.msg.String, latch=True)
        geom_pub.publish( geometry_filename )

        self.tf_pub = rospy.Publisher('/pinhole_cal/tf', Transform, latch=True)

        rospy.Subscriber("pose", Pose, self.on_pose)

    def on_pose(self, pose_msg):
        tf_msg = Transform()
        for attr in ('x','y','z'):
            setattr(tf_msg.translation,attr, getattr( pose_msg.position, attr))
        tf_msg.rotation = pose_msg.orientation
        self.tf_pub.publish( tf_msg )

    def run(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('drive_extrinsic_display_calibration')

    parser = argparse.ArgumentParser()
    parser.add_argument('intrinsic_fname', type=str,
                        help='filename  (.bag or .yaml) intrinsic parameters')
    parser.add_argument('geom_fname', type=str,
                        help='filename  (.json or .osg) specifying display geometry')

    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    print 'args',args
    print args.intrinsic_fname
    print args.geom_fname


    cam = camera_model.load_camera_from_file( args.intrinsic_fname,
                                              extrinsics_required=False )
    app = MyApp(cam, args.geom_fname)
    app.run()
