#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode: nil; indent-offset: 4 -*-
import os.path
import argparse
import yaml
import numpy as np

import roslib; roslib.load_manifest('flyvr')

import rospy
import std_msgs.msg
from geometry_msgs.msg import Pose2D

import simple_geom
import camera_model
import display_client

import rosgobject.wrappers
from gi.repository import Gtk

def nice_float_fmt(treeviewcolumn, cell, model, iter, column):
    float_in = model.get_value(iter, column)
    cell.set_property('text', '%g'%float_in )

FULLSCREEN='<full screen>'

VDISP=0
TEXU=1
TEXV=2
DISPLAYX=3
DISPLAYY=4
SHOWPT=5
JOYLISTEN=6

class UI:
    def __init__(self, ds, cam, geometry_filename):
        self.dsc = display_client.DisplayServerProxy(ds,wait=True)

        joy_sub = rospy.Subscriber('joy_click_pose', Pose2D, self.on_joy_callback)

        #self.dsc.set_mode('Stimulus2DBlit') # let joystick_cursor node set the mode

        with open(geometry_filename,mode='r') as fd:
            self._geom_dict = yaml.load( fd )
        self.geom = simple_geom.Geometry(filename=geometry_filename)

        me = os.path.dirname(os.path.abspath(__file__))
        ui_fname = os.path.join(me,"extrinsic-wizard.ui")

        self._ui = Gtk.Builder()
        self._ui.add_from_file(ui_fname)

        self._build_ui()

        self.a1 = a1 = self._ui.get_object("assistant1")
        #a1.set_default_size(600,400)
        a1.connect("delete-event", rosgobject.main_quit)
        a1.show_all()

    def on_joy_callback(self, msg):
        # called in some ROS thread
        print 'got click', msg

    def _build_ui(self):
        # setup vdisp combobox ----------------
        di = self.dsc.get_display_info()
        #cb1 = self._ui.get_object('selectviewport_combobox1')
        self.vdisp_store = Gtk.ListStore(str)

        if 'virtualDisplays' in di:
            for viewport_dict in di['virtualDisplays']:
                #cb1.append_text( viewport_dict['id'] )
                self.vdisp_store.append([viewport_dict['id']])
        else:
            viewport_dict = None # full screen
            #cb1.append(FULLSCREEN)
            self.vdisp_store.append(FULLSCREEN)

        # create treeview --------------------------

        self.liststore = Gtk.ListStore(str, float, float, float, float, bool, bool)

        treeview = self._ui.get_object('treeview1')
        #treeview.get_selection().set_mode( Gtk.SELECTION_SINGLE )
        treeview.set_model( self.liststore )

        renderer_text = Gtk.CellRendererCombo()
        renderer_text.set_property("model", self.vdisp_store )
        renderer_text.set_property("text-column", VDISP)
        renderer_text.set_property("editable", True)
        #renderer_text.connect("edited", self.on_U_edited)
        column_text = Gtk.TreeViewColumn("virtual display", renderer_text, text=VDISP)
        #column_text.set_cell_data_func(renderer_text, nice_float_fmt, func_data=TEXU)
        treeview.append_column(column_text)

        renderer_text = Gtk.CellRendererText()
        #renderer_text.set_property("editable", True)
        #renderer_text.connect("edited", self.on_U_edited)
        column_text = Gtk.TreeViewColumn("texture U", renderer_text, text=TEXU)
        column_text.set_cell_data_func(renderer_text, nice_float_fmt, func_data=TEXU)
        treeview.append_column(column_text)

        renderer_text = Gtk.CellRendererText()
        #renderer_text.set_property("editable", True)
        #renderer_text.connect("edited", self.on_V_edited)
        column_text = Gtk.TreeViewColumn("texture V", renderer_text, text=TEXV)
        column_text.set_cell_data_func(renderer_text, nice_float_fmt, func_data=TEXV)
        treeview.append_column(column_text)

        renderer_text = Gtk.CellRendererText()
        column_text = Gtk.TreeViewColumn("display X", renderer_text, text=DISPLAYX)
        column_text.set_cell_data_func(renderer_text, nice_float_fmt, func_data=DISPLAYX)
        treeview.append_column(column_text)

        renderer_text = Gtk.CellRendererText()
        column_text = Gtk.TreeViewColumn("display Y", renderer_text, text=DISPLAYY)
        column_text.set_cell_data_func(renderer_text, nice_float_fmt, func_data=DISPLAYY)
        treeview.append_column(column_text)

        renderer_toggle = Gtk.CellRendererToggle()
        renderer_toggle.connect("toggled", self.on_toggle_point_show)
        column_toggle = Gtk.TreeViewColumn("show", renderer_toggle, active=SHOWPT)
        treeview.append_column(column_toggle)

        renderer_pixbuf = Gtk.CellRendererToggle()
        renderer_pixbuf.set_radio(True)
        renderer_pixbuf.connect("toggled", self.on_do_point)
        column_pixbuf = Gtk.TreeViewColumn('Joystick select', renderer_pixbuf, active=JOYLISTEN)
        treeview.append_column(column_pixbuf)

        # connect treeview buttons
        add_button = self._ui.get_object("UV_add_button")
        add_button.connect("clicked", self.on_add_UV)

        remove_button = self._ui.get_object("UV_remove_button")
        remove_button.connect("clicked", self.on_remove_UV)

    def on_do_point(self, widget, path):
        selected_path = Gtk.TreePath(path)
        # perform mutually-exclusive radio button setting
        for row in self.liststore:
            row[JOYLISTEN] = (row.path == selected_path)
        val = self.liststore[path]

    def _get_default_vdisp(self):
        di = self.dsc.get_display_info()
        if 'virtualDisplays' in di:
            val = di['virtualDisplays'][0]['id']
        else:
            val = FULLSCREEN
        return val

    def on_add_UV(self, button):
        vdisp = self._get_default_vdisp()
        self._add_pt_entry(vdisp, np.nan, np.nan )

    def on_remove_UV(self,button):
        treeview = self._ui.get_object('treeview1')
        selection = treeview.get_selection()
        sel = selection.get_selected()
        if not sel[1] == None:
            self.liststore.remove( sel[1] )

    def _add_pt_entry(self, vdisp, texU, texV,
                      displayX=float(np.nan), displayY=float(np.nan),
                      show_point=False, joy_listen=False):
        self.liststore.append([vdisp, texU, texV,
                               displayX, displayY,
                               show_point, joy_listen])

    def on_toggle_point_show(self, widget, path):
        self.liststore[path][SHOWPT] = not self.liststore[path][SHOWPT]
        self.update_bg_image()

    def update_bg_image(self):
        arr = np.zeros( (self.dsc.height,self.dsc.width), dtype=np.uint8 )
        showing = []
        for row in self.liststore:
            if not row[SHOWPT]:
                continue
            xf,yf = row[DISPLAYX], row[DISPLAYY]
            try:
                x = int(np.round(xf))
                y = int(np.round(yf))
            except ValueError:
                # Likely cannot convert nan to integer.
                continue
            #did_it = False
            if 0 <= x and x < self.dsc.width:
                if 0 <= y and y < self.dsc.height:
                    arr[y,x] = 255
                    #did_it = True
                    showing.append( (x,y) )
            # if not did_it:
            #     print 'DEBUG: could not show point (out of range)',row
        print 'showing',x,y
        self.dsc.show_pixels(arr)

if __name__ == "__main__":
    #rospy.init_node("extrinsic_wizard",disable_signals=False)
    rospy.init_node("extrinsic_wizard")
    rosgobject.get_ros_thread() #ensure ros is spinning
    rosgobject.add_console_logger()


    parser = argparse.ArgumentParser()

    parser.add_argument('--intrinsic_fname', type=str, required=True,
                        help='filename  (.bag or .yaml) intrinsic parameters')

    parser.add_argument('--geom_fname', type=str, required=True,
                        help='filename  (.json) specifying display geometry')

    parser.add_argument('--display_server', type=str,
                        required=True,
                        help='the path of the display server to configure')

    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    cam = camera_model.load_camera_from_file( args.intrinsic_fname,
                                              extrinsics_required=False )

    u = UI(args.display_server, cam, args.geom_fname)

    Gtk.main()
