#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode: nil; indent-offset: 4 -*-
import os.path
import argparse
import yaml
import numpy as np
from collections import defaultdict

import roslib; roslib.load_manifest('flyvr')

import rospy
import std_msgs.msg
from geometry_msgs.msg import Pose2D

import simple_geom
import camera_model
import display_client

import rosgobject.core
import rosgobject.wrappers
from gi.repository import Gtk

def nice_float_fmt(treeviewcolumn, cell, model, iter, column):
    float_in = model.get_value(iter, column)
    cell.set_property('text', '%g'%float_in )

FULLSCREEN='<full screen>'

VDISP=0
TEXU=1
TEXV=2
DISPLAYX=3
DISPLAYY=4
SHOWPT=5
JOYLISTEN=6

class UI:
    def __init__(self, ds, cam, geometry_filename):
        self.dsc = display_client.DisplayServerProxy(ds,wait=True)

        rosgobject.core.SubscriberGObject('joy_click_pose', Pose2D).connect('message', self.on_joy_callback)

        self.yamlfilter = Gtk.FileFilter()
        self.yamlfilter.set_name("YAML Files")
        self.yamlfilter.add_pattern("*.yaml")

        with open(geometry_filename,mode='r') as fd:
            self._geom_dict = yaml.load( fd )
        self.geom = simple_geom.Geometry(filename=geometry_filename)

        me = os.path.dirname(os.path.abspath(__file__))
        ui_fname = os.path.join(me,"extrinsic-wizard.ui")

        self._ui = Gtk.Builder()
        self._ui.add_from_file(ui_fname)

        self._build_ui()

        self.a1 = a1 = self._ui.get_object("assistant1")
        a1.connect("delete-event", rosgobject.main_quit)
        a1.show_all()

    def on_joy_callback(self, widget, msg):
        if not len(self.liststore):
            return

        for row in self.liststore:
            if row[JOYLISTEN]:
                break

        if not row[JOYLISTEN]:
            # no row selected
            return

        row[DISPLAYX] = msg.x
        row[DISPLAYY] = msg.y

    def _build_ui(self):
        # setup vdisp combobox ----------------
        di = self.dsc.get_display_info()
        self.vdisp_store = Gtk.ListStore(str,int)

        if 'virtualDisplays' in di:
            for viewport_dict in di['virtualDisplays']:
                self.vdisp_store.append([viewport_dict['id'],0])
        else:
            viewport_dict = None # full screen
            self.vdisp_store.append([FULLSCREEN,0])

        # create vdisp treeview -----------------------

        treeview = self._ui.get_object('vdisp_treeview')
        treeview.set_model( self.vdisp_store )

        renderer = Gtk.CellRendererText()
        column = Gtk.TreeViewColumn("virtual display", renderer, text=0)
        column.set_sort_column_id(0)
        treeview.append_column(column)

        renderer = Gtk.CellRendererText()
        column = Gtk.TreeViewColumn("count", renderer, text=1)
        column.set_sort_column_id(1)
        treeview.append_column(column)

        # create point treeview -----------------------

        self.liststore = Gtk.ListStore(str, float, float, float, float, bool, bool)

        treeview = self._ui.get_object('treeview1')
        treeview.set_model( self.liststore )

        renderer_text = Gtk.CellRendererCombo(model=self.vdisp_store,
                                              text_column=VDISP,
                                              editable=True)
        renderer_text.connect("edited", self.on_edit_vdisp, VDISP)
        column = Gtk.TreeViewColumn("virtual display", renderer_text, text=VDISP)
        column.set_sort_column_id(VDISP)
        treeview.append_column(column)

        renderer_text = Gtk.CellRendererText(editable=True)
        renderer_text.connect("edited", self.on_edit_cell, TEXU)
        column = Gtk.TreeViewColumn("texture U", renderer_text, text=TEXU)
        column.set_cell_data_func(renderer_text, nice_float_fmt, func_data=TEXU)
        column.set_sort_column_id(TEXU)
        treeview.append_column(column)

        renderer_text = Gtk.CellRendererText(editable=True)
        renderer_text.connect("edited", self.on_edit_cell, TEXV)
        column = Gtk.TreeViewColumn("texture V", renderer_text, text=TEXV)
        column.set_cell_data_func(renderer_text, nice_float_fmt, func_data=TEXV)
        column.set_sort_column_id(TEXV)
        treeview.append_column(column)

        renderer_text = Gtk.CellRendererText(editable=True)
        renderer_text.connect("edited", self.on_edit_cell, DISPLAYX)
        column = Gtk.TreeViewColumn("display X", renderer_text, text=DISPLAYX)
        column.set_cell_data_func(renderer_text, nice_float_fmt, func_data=DISPLAYX)
        column.set_sort_column_id(DISPLAYX)
        treeview.append_column(column)

        renderer_text = Gtk.CellRendererText(editable=True)
        renderer_text.connect("edited", self.on_edit_cell, DISPLAYY)
        column = Gtk.TreeViewColumn("display Y", renderer_text, text=DISPLAYY)
        column.set_cell_data_func(renderer_text, nice_float_fmt, func_data=DISPLAYY)
        column.set_sort_column_id(DISPLAYY)
        treeview.append_column(column)

        renderer_toggle = Gtk.CellRendererToggle()
        renderer_toggle.connect("toggled", self.on_toggle_point_show)
        column = Gtk.TreeViewColumn("show", renderer_toggle, active=SHOWPT)
        column.set_sort_column_id(SHOWPT)
        treeview.append_column(column)

        renderer_pixbuf = Gtk.CellRendererToggle()
        renderer_pixbuf.set_radio(True)
        renderer_pixbuf.connect("toggled", self.on_do_point)
        column = Gtk.TreeViewColumn('Joystick select', renderer_pixbuf, active=JOYLISTEN)
        treeview.append_column(column)

        self.liststore.connect("row-changed",  self.on_points_updated)
        self.liststore.connect("row-inserted", self.on_points_updated)
        self.liststore.connect("row-deleted",  self.on_points_updated)

        # connect treeview buttons ---------------------------
        self._ui.get_object('UV_add_button').connect('clicked', self.on_add_UV)
        self._ui.get_object('UV_remove_button').connect('clicked', self.on_remove_UV)

        self._ui.get_object('save_points_button').connect('clicked', self.on_save_points_button)
        self._ui.get_object('load_points_button').connect('clicked', self.on_load_points_button)

    def on_points_updated(self, *args):
        vdisps = defaultdict(int)
        for row in self.liststore:
            vdisps[ row[VDISP] ] += 1

        for row in self.vdisp_store:
            vdisp = row[0]
            row[1] = vdisps[ vdisp ]

    def on_edit_vdisp(self,widget,path,textval,colnum):
        self.liststore[path][colnum] = textval
        self.update_bg_image()

    def on_edit_cell(self,widget,path,textval,colnum):
        value = float(textval)
        self.liststore[path][colnum] = value
        self.update_bg_image()

    def on_do_point(self, widget, path):
        selected_path = Gtk.TreePath(path)
        # perform mutually-exclusive radio button setting
        for row in self.liststore:
            row[JOYLISTEN] = (row.path == selected_path)

    def _get_default_vdisp(self):
        di = self.dsc.get_display_info()
        if 'virtualDisplays' in di:
            val = di['virtualDisplays'][0]['id']
        else:
            val = FULLSCREEN
        return val

    def liststore_to_list(self):
        result = []
        for row in self.liststore:
            rowdict = dict(
                virtual_display = row[VDISP],
                texture_u = row[TEXU],
                texture_v = row[TEXV],
                display_x = row[DISPLAYX],
                display_y = row[DISPLAYY],
                )
            result.append( rowdict )
        return result

    def list_to_liststore(self,in_list):
        for rowdict in in_list:
            self._add_pt_entry( rowdict['virtual_display'],
                                rowdict['texture_u'],
                                rowdict['texture_v'],
                                displayX=rowdict['display_x'],
                                displayY=rowdict['display_y'],
                                )
        self.update_bg_image()

    def on_add_UV(self, button):
        vdisp = self._get_default_vdisp()
        self._add_pt_entry(vdisp, np.nan, np.nan )
        self.update_bg_image()

    def on_remove_UV(self,button):
        treeview = self._ui.get_object('treeview1')
        selection = treeview.get_selection()
        sel = selection.get_selected()
        if not sel[1] == None:
            self.liststore.remove( sel[1] )

    def on_save_points_button(self, button):
        filechooserdialog = Gtk.FileChooserDialog(title="FileChooserDialog",
                                                  parent=None,
                                                  action=Gtk.FileChooserAction.SAVE,
                                                  buttons=(Gtk.STOCK_OK, Gtk.ResponseType.OK,
                                                           Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL))
        filechooserdialog.add_filter( self.yamlfilter )
        filechooserdialog.set_do_overwrite_confirmation(True)

        response = filechooserdialog.run()

        if response == Gtk.ResponseType.OK:
            fname = filechooserdialog.get_filename()
            obj = self.liststore_to_list()
            buf = yaml.dump(obj)
            with open(fname,mode='w') as fd:
                fd.write(buf)

        filechooserdialog.destroy()

    def on_load_points_button(self, button):
        filechooserdialog = Gtk.FileChooserDialog(title="FileChooserDialog",
                                                  parent=None,
                                                  buttons=(Gtk.STOCK_OK, Gtk.ResponseType.OK,
                                                           Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL))

        response = filechooserdialog.run()

        if response == Gtk.ResponseType.OK:
            fname = filechooserdialog.get_filename()
            with open(fname,mode='r') as fd:
                buf = fd.read()

            obj = yaml.load(buf)
            self.list_to_liststore(obj)

        filechooserdialog.destroy()

    def _add_pt_entry(self, vdisp, texU, texV,
                      displayX=float(np.nan), displayY=float(np.nan),
                      show_point=False, joy_listen=False):
        self.liststore.append([vdisp, texU, texV,
                               displayX, displayY,
                               show_point, joy_listen])

    def on_toggle_point_show(self, widget, path):
        self.liststore[path][SHOWPT] = not self.liststore[path][SHOWPT]
        self.update_bg_image()

    def update_bg_image(self):
        arr = np.zeros( (self.dsc.height,self.dsc.width), dtype=np.uint8 )
        showing = []
        for row in self.liststore:
            if not row[SHOWPT]:
                continue
            xf,yf = row[DISPLAYX], row[DISPLAYY]
            try:
                x = int(np.round(xf))
                y = int(np.round(yf))
            except ValueError:
                # Likely cannot convert nan to integer.
                continue
            if 0 <= x and x < self.dsc.width:
                if 0 <= y and y < self.dsc.height:
                    arr[y,x] = 255
                    showing.append( (x,y) )
        self.dsc.show_pixels(arr)

if __name__ == "__main__":
    rospy.init_node("extrinsic_wizard")
    rosgobject.get_ros_thread() #ensure ros is spinning
    rosgobject.add_console_logger()


    parser = argparse.ArgumentParser()

    parser.add_argument('--intrinsic_fname', type=str, required=True,
                        help='filename  (.bag or .yaml) intrinsic parameters')

    parser.add_argument('--geom_fname', type=str, required=True,
                        help='filename  (.json) specifying display geometry')

    parser.add_argument('--display_server', type=str,
                        required=True,
                        help='the path of the display server to configure')

    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    cam = camera_model.load_camera_from_file( args.intrinsic_fname,
                                              extrinsics_required=False )

    u = UI(args.display_server, cam, args.geom_fname)

    Gtk.main()
