#!/usr/bin/env python

import roslib;
roslib.load_manifest('vros_display')
roslib.load_manifest('std_msgs')
import rospy

from std_msgs.msg import String

import json
import pickle
import threading
import fnmatch
import argparse
import os.path

import numpy as np
import scipy.misc
import cv,cv2

class Foo:
    def __init__(self, cameras_glob):
        self.dat = {}
        self.res = {}
        self.windows = {}
        self.cameras_glob = cameras_glob
        self.lock = threading.Lock()
        cv2.startWindowThread()

    def load_from_pickle(self, base='mcamall'):
        with open('%s/results.pkl' % base) as f:
            self.dat = pickle.load(f)

        with open('%s/resolution.pkl' % base) as f:
            self.res = pickle.load(f)

        self._update_windows()

    def from_ros(self):
        rospy.Subscriber("/multicamselfcal_everything/points", String, self._on_points)
        rospy.Subscriber("/multicamselfcal_everything/resolution", String, self._on_resolution)

    def _on_points(self, data):
        with self.lock:
            self.dat = json.loads(data.data)
        self._update_windows()

    def _on_resolution(self, data):
        with self.lock:
            self.res = json.loads(data.data)

    def _update_windows(self):
        if self.dat and self.res and (len(self.dat) == len(self.res)):
            allcams = self.res.keys()
            for handle in fnmatch.filter(allcams, self.cameras_glob):
                if handle not in self.windows:
                    cv2.namedWindow(handle, cv.CV_WINDOW_NORMAL)
                    self.windows[handle] = True
                arr,npts = self._make_array(handle)
                cv2.putText(arr, "%s (%d)" % (handle,npts), (100,100), cv2.FONT_HERSHEY_PLAIN, 1.0, (255, 255, 255))
                cv2.imshow(handle, arr)

    def _make_array(self, cam):
        w,h = self.res[cam]
        #swap h,w as resolution saves in image coord convention and scipy.misc.imsave saves
        #from matrix convention
        npts = 0
        arr = np.zeros((h,w,4),dtype=np.uint8)
        arr[:,:,3]=255 #opaque
        for pt in self.dat[cam]:
            #again swap image coords -> matrix notation
            col,row = pt
            if np.any(np.isnan(pt)):
                continue
            arr[row,col,1] = 255
            npts += 1
        return arr, npts

    def write_pngs(self):
        for cam in self.dat:
            arr,npts = self._make_array(cam)
            scipy.misc.imsave('coverage-%s.png' % cam.replace('/',''),arr)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--cameras', type=str, default='*',
        help='glob pattern of cameras to show, e.g. /Basler*')
    parser.add_argument(
        '--from-dir', type=str,
        help='load from dir of pkl files')
    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    rospy.init_node('viewcalibpoints', anonymous=True)
    r = Foo(args.cameras)
    if args.from_dir:
        r.load_from_pickle(os.path.abspath(args.from_dir))
    else:
        r.from_ros()
    rospy.spin()
    
